#                              上机作业A1：初试环境和工具

##                                      10205501456    彭林航      2022/9/18

### 1 **环境搭建和工具安装**

### 2 **常用工具命令操作练习**

**要求**：在终端分别执行下述命令，如系统没有，请自行安装。使用 man 命令获得相关命令的文档，了解命令用法与选项含义，理解输出的数据，在此基础上回答问题。

**提示**：部分命令输出结果可能很长，尝试使用管道与 head 命令控制输出的行数，例如：<cmd> | head -n 10；部分命令可能需要 sudo 权限才可以正确执行。

#### 1）**$uname -a**

#####     a) 分析输出结果包含了哪些信息：

​    umame命令用于打印系统信息，输出的结果为：

```
Linux ubuntu 5.15.0-46-generic #49~20.04.1-Ubuntu SMP Thu Aug 4 19:15:44 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux
```

​      包含了以下的信息：

- 系统名称：Linux
- 节点名称：ubuntu
- 操作系统的发行版本：5.15.0-46-generic
- 内核版本：#49~20.04.1-Ubuntu SMP Thu Aug 4 19:15:44 UTC 2022
- 机器硬件（CPU）名、硬件平台：x86_64
- 操作系统：GNU/Linux

##### 	b) Linux 内核版本与指令集架构是什么?

- 内核版本为 #49~20.04.1-Ubuntu SMP Thu Aug 4 19:15:44 UTC 2022
- 指令集架构为 x86_64位架构

#### 2）**$sysctl -a**

##### 	a) 该命令的功能是什么？-a 选项的含义是什么？

​     sysctl命令被用于在内核运行时动态地配置内核的运行参数

​	 -a选项显示当前可用的所有的系统参数

##### 	b) 输出结果与目录/proc/sys 的关系是什么？

​       输出的结果即为在/proc/sys目录下存放着的大多数的内核参数，查询得到的是所有可修改的变量名，这些参数的调整是即时的，并且在系统运行的整个生命周期之间都有效（直到再次改变它们或者系统重启）

#### 3）**$lscpu**

##### 	a) 分析输出结果包含了哪些信息

​    lscpu命令用来显示cpu架构的相关信息，以下为具体的输出结果

```
Architecture:                    x86_64 #架构
CPU op-mode(s):                  32-bit, 64-bit #运行方式
Byte Order:                      Little Endian #字节顺序：小端法
CPU(s):                          2 #cpu的逻辑核总数
On-line CPU(s) list:             0,1 #在线的cpu逻辑核总数
Thread(s) per core:              1 #每个物理核的超线程数
Core(s) per socket:              1 #每个插槽的物理核数
Socket(s):                       2 #cpu插槽数
NUMA node(s):                    1 #非统一内存访问节点
Vendor ID:                       GenuineIntel #cpu厂商ID
CPU family:                      6 #cpu系列
Model:                           126 #型号
Model name:                      Intel(R) Core(TM) i7-1065G7 CPU @ 1.30GHz
Stepping:                        5 #步进
CPU MHz:                         1497.598 #cpu主频
Hypervisor vendor:               VMware #虚拟化架构
Virtualization type:             full #支持的虚拟化技术
L1d cache:                       96 KiB #一级缓存（L1数据缓存）
L1i cache:                       64 KiB #一级缓存（L1指令缓存）
L2 cache:                        1 MiB #二级缓存
L3 cache:                        16 MiB #三级缓存
NUMA node0 CPU(s):               0,1 #逻辑cpu和NUMA节点映射
```

##### 	b) 处理器型号是什么？包含多少个物理核（physical core）？是否有硬件线程（hardware thread）？

​    处理器的型号是126，包含2个物理核，具有硬件线程

#### 4）**$dmidecode**

##### 	a) 该命令的功能是什么？

​    dmidecode命令通过DMI来获取得到主机的硬件信息，将DMI数据库中的信息解码，以可读的文本方式显示。

##### 	b) 观察输出结果，以内存为例，可以获得哪些信息？

​    通过dmidecode -t memory命令得到内存的信息，例如得到以下的输出结果：

```
Handle 0x0222, DMI type 17, 34 bytes
Memory Device
	Array Handle: 0x0025 #阵列处理
	Error Information Handle: No Error #错误信息的处理
	Total Width: 32 bits #总宽度
	Data Width: 32 bits #数据宽度
	Size: No Module Installed #大小
	Form Factor: DIMM 
	Set: None
	Locator: NVD #63
	Bank Locator: NVD #63
	Type: Other
	Type Detail: Unknown #输入详细信息：同步
	Speed: Unknown #输入速度
	Manufacturer: Not Specified #制造商
	Serial Number: Not Specified #序号
	Asset Tag: Not Specified
	Part Number: Not Specified
	Rank: Unknown
	Configured Memory Speed: Unknown
```

#### 5）**$numactl -H**

##### 	a) 该命令的功能是什么？-H 选项的含义是什么？

​    numactl命令用于查看NUMA节点配置和运行状态、控制进程与共享存储的 NUMA 技术机制

​    -H选项表示查看当前对象为服务器

##### 	b) NUMA 节点数量有多少个？

​    部分输出为：

```
available: 1 nodes (0)
```

​    说明NUMA节点数量为1

#### 6） **$top与$htop**

​	**注意**：执行该命令后会进入交互式界面，按 q 退出。

##### 	a) 以 top 工具为例，交互式界面的每一栏分别表示什么？

- PID：进程标识号，每个process的ID
- USER：进程所有者的用户名
- PR：priority，进程的优先级别（级别越小越早被执行）
- NI：进程的优先级别数值（数值越小越早被执行）
- VIRT：进程占用的虚拟内存值，单位kb
- RES：进程占用的物理内存值，单位kb
- SHR：进程使用的共享内存值，单位kb
- S：进程的状态，其中S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值是负数
- %CPU：该进程占用的CPU使用率
- %MEM：该进程占用的物理内存和总内存的百分比
- TIME+：该进程启动后占用的总的CPU时间 ( CPU 使用时间的累加 )，单位毫秒
- COMMAND：进程启动的启动命令名称，如这一行显示不下，进程会有一个完整的命令行

##### 	b) 简要比较两种工具的差别。

​    htop命令类似于top命令，但可以在垂直和水平方向上滚动，能够看到系统上运行的所有进程，不用输入进程的PID就可以对此进程执行操作。

​    htop命令还具有自定义排序显示、在其中kill进程、调整进程优先级、显示指定用户的进程、以树形表形式展现进程、改变自动刷新的频率、显示lsof的输出等top命令不具有的操作

#### 7） **$free**

##### 	a) 分析输出结果，解释结果显示两行数据的含义。

​    free命令提供物理内存和交换空间总量以及系统中的可用和已用内存以及交换空间的信息。

```
             total        used        free       shared    buff/cache  available
Mem:        3983204      906996     2396824        1964      679384     2844292
Swap:        945416           0      945416
```
​    第一行标题栏中，总数total代表应用程序可以使用的内存总量，已使用used代表已使用的内存，free代表空闲/未使用的内存，buff/chche表示内核缓冲区以及页面高速缓存和slab分配使用的内存组合，available表示估计可用于启动新应用程序而无需swap空间的内存量。

​    第二、三行分别表示内存和交换空间的信息。

##### 	b) 这些数据以什么为单位的？

​     不带任何选项的free命令，将显示内存的信息以kibibyte为单位，1kibibyte(KiB)是1024字节

#### 8）**$vmstat 1**

#### 9）**$mpstat -P ALL 1**

#### 10）**$pidstat 1**

#### 11）**$iostat -xz 1**

​	**注意**：可以通过 ctrl+C 终止上述命令的执行。

##### 	a) 对于 8)到 11)这 4 条命令，命令传入的参数 1 表示什么意思？

​     传入的参数1表示显示报告的次数（报告的更新次数）

##### 	b) 比较这 4 条命令分别统计了哪些方面信息：

- vmstat命令显示虚拟内存状态，统计了关于进程、内存、I/O等系统整体的运行状态，只能统计整体的情况，不能针对特定进程等进行分析
- mpstat命令显示各个可用cpu的状态，不但能查看所有cpu的平均状态信息（不带参数），而且能够查看特定cpu的信息
- pidstat命令用于监控全部或指定进程的cpu、内存、线程、设备IO等系统资源的占用情况
- iostat命令用于监视系统输入输出设备和cpu的使用情况。汇报磁盘活动统计情况，同时也会汇报出CPU使用情况，同vmstat一样，不能对某个进程进行深入分析，仅对系统的整体情况进行分析。

#### 12）**$sar -n DEV 1**

##### 	a) 命令传入的参数 1 表示什么意思？

​    传入的参数1表示显示报告的次数

##### 	b) 选项-n DEV，会获得哪些性能数据？

​    sar命令是系统运行状态统计工具，-n选项是对网络使用情况进行显示，-n DEV选项可显示eth0、eth1等网卡的信息，具体的信息数据有：

- rxpck/s：每秒接收的数据包总数
- txpck/s：每秒传输的数据包总数
- rxkB/s：每秒接收的kB总数
- txkB/s：每秒传输的kB总数
- rxcmp/s：每秒接收的压缩包数（用于 cslip 等）
- txcmp/s：每秒传输的压缩包数
- rxmcst/s：每秒接收的多播（multicast）数据包数

## 3 **MIT 6.172 Performance Engineering of Software Systems “Homework 1: Getting Started”**

- **Write-up 2:** Answer the questions in the comments in **pointer.c**. For example, why are some of the statements valid and some are not?

  在代码中进行对应作答：

  ```c
  int main(int argc, char * argv[]) {  // What is the type of argv:指向字符的指针的指针 
    int i = 5;
    // The & operator here gets the address of i and stores it into pi
    int * pi = &i;
    // The * operator here dereferences pi and stores the value -- 5 --
    // into j.
    int j = *pi;
  
    char c[] = "6.172";
    char * pc = c;  // Valid assignment: c acts like a pointer to c[0] here.
    char d = *pc;
    printf("char d = %c\n", d);  // What does this print:6
  
    // compound types are read right to left in C.
    // pcp is a pointer to a pointer to a char, meaning that
    // pcp stores the address of a char pointer.
    char ** pcp;
    pcp = argv;  // Why is this assignment valid:argv也是指向字符的指针的指针，赋值是合法的
  
    const char * pcc = c;  // pcc is a pointer to char constant
    char const * pcc2 = c;  // What is the type of pcc2:指向常量字符的常量指针
  
    // For each of the following, why is the assignment:
    *pcc = '7';  // invalid:pcc是指向常量字符的指针，常量字符的值不可以被改变
    pcc = *pcp;  // valid:并没有改变常量字符的值，而是改变了指针指向的位置
    pcc = argv[0];  // valid:并没有改变常量字符的值，而是改变了指针指向的位置
  
    char * const cp = c;  // cp is a const pointer to char
    // For each of the following, why is the assignment:
    cp = *pcp;  // invalid:常量指针指向的位置不能被改变
    cp = *argv;  // invalid:常量指针指向的位置不能被改变
    *cp = '!';  // valid:指向的字符并不是常量的，改变非常量字符是合法的
  
    const char * const cpc = c;  // cpc is a const pointer to char const
    // For each of the following, why is the assignment:
    cpc = *pcp;  // invalid:常量指针指向的位置不能被改变
    cpc = argv[0];  // invalid:常量指针指向的位置不能被改变
    *cpc = '@';  // invalid:指向的字符是常量的，故不能够被改变
  
    return 0;
  }
  ```

  

- **Write-up 3:** For each of the types in the **sizes.c** exercise above, print the size of a pointer to that type. Recall that obtaining the address of an array or struct requires the & operator. Provide the output of your program (which should include the sizes of both the actual type and a pointer to it) in the writeup. 

  输出的结果为：

  ![image-20220921100952378](./pic/answer_3)

  ```
  size of i: 4 bytes 
  size of pi: 8 bytes 
  size of c[0]: 1 bytes 
  size of pc: 8 bytes 
  size of pcp: 8 bytes 
  size of pcc: 8 bytes 
  size of pcc2: 8 bytes 
  size of cp: 8 bytes 
  size of cpc: 8 bytes 
  ```

  - int类型大小为4 bytes，指向int类型的指针为8bytes

  - char类型大小为1 bytes，指向char类型的指针为8bytes

  - 指向char类型的指针的指针大小为8 bytes 

  - 无论指向的数据类型是否为常量，指针本身是否为常量，大小均为bytes

    ∴  可以看到指向不同数据类型的指针，其大小都为8 bytes

  

- **Write-up 4:** File **swap.c** contains the code to swap two integers. Rewrite the **swap()** function using pointers and make appropriate changes in **main()** function so that the values are swapped with a call to **swap()**. Compile the code with make swap and run the program with **./swap**. Provide your edited code in the writeup. Verify that the results of both **sizes.c** and **swap.c** are correct by using the python script **verifier.py**. 

  编辑后的swap.c

  ```c
  // Copyright (c) 2012 MIT License by 6.172 Staff
  
  #include <stdio.h>
  #include <stdlib.h>
  #include <stdint.h>
  
  void swap(int *i, int *j) {
    int temp = *i;
    *i = *j;
    *j = temp;
  }
  
  int main() {
    int k = 1;
    int m = 2;
    swap(&k, &m);
    // What does this print
    printf("k = %d, m = %d\n", k, m);
  
    return 0;
  }
  ```

  运行 verifier.py脚本，得到的结果如下图所示：

  ![image-20220920152628308](./pic/answer_4)

  

- **Write-up 5:** Now, what do you see when you type **make clean; make**? 

  有如下的结果：

  ![image-20220920152628308](./pic/answer_5)

  

- **Write-up 6:** What output do you see from AddressSanitizer regarding the memory bug? Paste it into your writeup here. 

  使用-fuse-ld=gold链接器在系统中找不到，将makefile中的LDFLAGS改为

  ```
  LDFLAGS := -lrt -flto
  ```

  运行 ./matrix_multiply 得到的结果：

  ![image-20220920161613232](./pic/answer_6)

  具体内容为：

  ```
  Setup
  Running matrix_multiply_run()...
  Elapsed execution time: 0.000001 sec
  
  =================================================================
  ==4036==ERROR: LeakSanitizer: detected memory leaks
  
  Direct leak of 48 byte(s) in 3 object(s) allocated from:
      #0 0x493a4d in malloc (/home/plh/homework1/matrix-multiply/matrix_multiply+0x493a4d)
      #1 0x4c3de9 in make_matrix /home/plh/homework1/matrix-multiply/matrix_multiply.c:38:24
      #2 0x7efd61804082 in __libc_start_main /build/glibc-SzIz7B/glibc-2.31/csu/../csu/libc-start.c:308:16
  
  Indirect leak of 192 byte(s) in 12 object(s) allocated from:
      #0 0x493a4d in malloc (/home/plh/homework1/matrix-multiply/matrix_multiply+0x493a4d)
      #1 0x4c3e77 in make_matrix /home/plh/homework1/matrix-multiply/matrix_multiply.c:47:35
  
  Indirect leak of 96 byte(s) in 3 object(s) allocated from:
      #0 0x493a4d in malloc (/home/plh/homework1/matrix-multiply/matrix_multiply+0x493a4d)
      #1 0x4c3e30 in make_matrix /home/plh/homework1/matrix-multiply/matrix_multiply.c:45:31
      #2 0x7efd61804082 in __libc_start_main /build/glibc-SzIz7B/glibc-2.31/csu/../csu/libc-start.c:308:16
  
  SUMMARY: AddressSanitizer: 336 byte(s) leaked in 18 allocation(s).
  ```

  

- **Write-up 7:** After you fifix your program, run **./matrix_multiply -p**. Paste the program output showing that the matrix multiplication is working correctly. 

  在matrix_multiply.c 代码中A、B矩阵相乘之前，加入如下代码使得矩阵C得到初始化

  ```c
    for (int i = 0; i < C->rows; i++) {
      for (int j = 0; j < C->cols; j++) {
        C->values[i][j] = 0;
      }
    }
  ```

  运行 ./matrix_multiply -p 之后得到如下结果：

  ![image-20220920175414940](./pic/answer_7)

  具体内容为：

  ```
  Setup
  Matrix A: 
  ------------
      3      7      8      1  
      7      9      8      3  
      1      2      6      7  
      9      8      1      9  
  ------------
  Matrix B: 
  ------------
      1      3      0      1  
      5      5      7      8  
      0      1      9      8  
      9      3      1      7  
  ------------
  Running matrix_multiply_run()...
  ---- RESULTS ----
  Result: 
  ------------
     47     55    122    130  
     79     83    138    164  
     74     40     75    114  
    130     95     74    144  
  ------------
  ---- END RESULTS ----
  Elapsed execution time: 0.000001 sec
  ```

  

- **Write-up 8:** Paste the output from Valgrind showing that there is no error in your program. 

  在testbed.c的代码中，在A、B矩阵相乘结束计时之后释放矩阵A、B占用的空间，在C矩阵输出之后，释放矩阵C占用的内存，如以下代码所示：
  
  ```c
    fprintf(stderr, "Running matrix_multiply_run()...\n");
  
    fasttime_t time1 = gettime();
    matrix_multiply_run(A, B, C);
    fasttime_t time2 = gettime();
  
    free_matrix(A);
    free_matrix(B);
    if (should_print) {
      printf("---- RESULTS ----\n");
      printf("Result: \n");
      print_matrix(C);
      printf("---- END RESULTS ----\n");
    }
  
    free_matrix(C);
  ```
  
  运行 valgrind ./matrix_multiply -p 得到的结果如下图：
  
  ![image-20220920192859736](./pic/answer_8)

具体的输出内容为：

```
==2614== Memcheck, a memory error detector
==2614== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==2614== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==2614== Command: ./matrix_multiply -p
==2614== 
Setup
Matrix A: 
------------
    3      7      8      1  
    7      9      8      3  
    1      2      6      7  
    9      8      1      9  
------------
Matrix B: 
------------
    1      3      0      1  
    5      5      7      8  
    0      1      9      8  
    9      3      1      7  
------------
Running matrix_multiply_run()...
---- RESULTS ----
Result: 
------------
   47     55    122    130  
   79     83    138    164  
   74     40     75    114  
  130     95     74    144  
------------
---- END RESULTS ----
Elapsed execution time: 0.001448 sec
==2614== 
==2614== HEAP SUMMARY:
==2614==     in use at exit: 336 bytes in 18 blocks
==2614==   total heap usage: 39 allocs, 21 frees, 1,680 bytes allocated
==2614== 
==2614== LEAK SUMMARY:
==2614==    definitely lost: 48 bytes in 3 blocks
==2614==    indirectly lost: 288 bytes in 15 blocks
==2614==      possibly lost: 0 bytes in 0 blocks
==2614==    still reachable: 0 bytes in 0 blocks
==2614==         suppressed: 0 bytes in 0 blocks
==2614== Rerun with --leak-check=full to see details of leaked memory
==2614== 
==2614== For lists of detected and suppressed errors, rerun with: -s
==2614== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
```

### 4 总结

​		通过本次上次作业，学习了收集监视系统运行参数的常用命令，并通过MIT 6.172 homework1的练习熟悉掌握了C中数据类型及其大小、指针、参数传递，学会了运用linux环境的构建并运行代码、调试、内存检查等工具
